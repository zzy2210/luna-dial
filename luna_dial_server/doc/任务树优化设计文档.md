# 任务树优化设计文档

## 背景

Luna Dial 的任务管理采用树形结构，支持年 → 季 → 月 → 周 → 日的层级关系。当前实现存在以下问题：

1. **性能问题**：任务树查询需要递归查询，在数据量大时性能较差
2. **功能缺失**：缺少分页查询、任务树视图、父任务链查询等核心功能
3. **查询复杂**：全局任务树视图需要多次查询组装

## 设计目标

### 核心需求
- [ ] 分页查看任务
- [ ] 查看指定任务的任务树
- [ ] 查看任务的父任务（遍历）
- [ ] 分页查看全部任务（按任务树形式排列）
- [ ] 分页查看日志

### 性能要求
- 支持长期大量任务累积（多年使用）
- 优化查询性能，减少数据库交互
- 支持10人以内的并发使用

## 解决方案：混合方案（数据库冗余字段 + 业务层树结构）

### 核心思想
通过在数据库层面添加冗余字段来优化查询性能，在业务层构建完整的树形结构。

## 技术实现

### 1. 数据库层面改动

#### 新增字段
```sql
ALTER TABLE tasks ADD COLUMN has_children BOOLEAN DEFAULT FALSE;
ALTER TABLE tasks ADD COLUMN children_count INT DEFAULT 0;
ALTER TABLE tasks ADD COLUMN root_task_id VARCHAR(36);
ALTER TABLE tasks ADD COLUMN tree_depth INT DEFAULT 0;
```

#### 字段说明
- `has_children`: 是否有子任务（快速判断）
- `children_count`: 直接子任务数量（统计和分页）
- `root_task_id`: 指向根任务ID（批量查询优化）
- `tree_depth`: 在树中的深度（排序和层级控制）

#### 索引优化
```sql
CREATE INDEX idx_tasks_root_task_id ON tasks(root_task_id);
CREATE INDEX idx_tasks_no_parent ON tasks(user_id) WHERE parent_id IS NULL OR parent_id = '';
CREATE INDEX idx_tasks_tree_depth ON tasks(tree_depth);
```

### 2. 业务层面改动

#### Task结构扩展
```go
type Task struct {
    // 原有字段...
    
    // 新增：树结构优化字段
    HasChildren   bool    `json:"has_children"`
    ChildrenCount int     `json:"children_count"`
    RootTaskID    string  `json:"root_task_id"`
    TreeDepth     int     `json:"tree_depth"`
    
    // 新增：内存构建的子任务列表
    Children      []*Task `json:"children,omitempty" gorm:"-"`
}
```

### 3. 核心查询策略

#### 获取任意任务的完整子任务树
```sql
-- 一次查询获取整个树
SELECT * FROM tasks 
WHERE user_id = ? AND (id = ? OR root_task_id = ?) 
AND status != 3  -- 默认不显示已取消的任务
ORDER BY tree_depth, created_at;
```

#### 全局任务树视图（分页）
```sql
-- 步骤1：分页获取根任务
SELECT * FROM tasks 
WHERE user_id = ? AND (parent_id IS NULL OR parent_id = '') 
AND status != 3
ORDER BY created_at 
LIMIT ? OFFSET ?;

-- 步骤2：批量获取所有相关子任务
SELECT * FROM tasks 
WHERE user_id = ? AND root_task_id IN (?, ?, ?, ...) 
AND status != 3
ORDER BY root_task_id, tree_depth, created_at;
```

#### 父任务链查询
利用现有递归逻辑，或通过root_task_id先找到根任务再构建路径。

### 4. API设计

#### 响应格式（嵌套树结构）
```json
{
  "code": 200,
  "message": "success",
  "data": [
    {
      "id": "task1",
      "title": "2024年目标",
      "task_type": 4,
      "tree_depth": 0,
      "has_children": true,
      "children_count": 2,
      "children": [
        {
          "id": "task2",
          "title": "Q1目标",
          "parent_id": "task1",
          "tree_depth": 1,
          "has_children": true,
          "children_count": 1,
          "children": [
            {
              "id": "task3",
              "title": "1月任务",
              "parent_id": "task2",
              "tree_depth": 2,
              "has_children": false,
              "children_count": 0,
              "children": []
            }
          ]
        }
      ]
    }
  ],
  "pagination": {
    "page": 1,
    "page_size": 10,
    "total": 50,
    "total_pages": 5,
    "has_next": true
  }
}
```

#### 新增API接口
1. **获取任务树**：`GET /api/v1/tasks/:task_id/tree`
2. **获取父任务链**：`GET /api/v1/tasks/:task_id/parents`
3. **移动任务**：`PUT /api/v1/tasks/:task_id/move`
4. **获取可选父任务**：`GET /api/v1/tasks/:task_id/possible-parents`

### 5. 数据一致性维护

#### 新建任务
```go
func CreateTask(task *Task) error {
    if task.ParentID != "" {
        parent := GetTask(task.ParentID)
        task.TreeDepth = parent.TreeDepth + 1
        task.RootTaskID = parent.RootTaskID
        UpdateParentChildrenCount(task.ParentID, +1)
    } else {
        task.TreeDepth = 0
        task.RootTaskID = task.ID  // 根任务指向自己
    }
    
    task.HasChildren = false
    task.ChildrenCount = 0
    return SaveTask(task)
}
```

#### 删除任务策略
**设计理念**：尽量不要隐藏自己的过往
- **推荐做法**：任务做不完时设置为"取消"状态，而不是删除
- **删除场景**：仅在确实需要物理删除时使用（测试数据、错误创建等）
- **删除策略**：采用级联删除，递归删除所有子任务

#### 移动任务
**常见场景**：将独立任务加入现有任务树
```go
func MoveTask(taskID, newParentID string) error {
    // 1. 更新旧父任务的计数
    // 2. 计算新的树信息
    // 3. 递归更新整个子树的树信息
    return UpdateTaskTreeInfo(taskID, newTreeDepth, newRootTaskID)
}
```

## 实施计划

### ✅ 阶段一：数据库层面修改 (最高优先级) - 已完成
1. ✅ 创建新的数据库迁移文件 `0004_add_tree_optimization.up.sql`
2. ✅ 添加新字段和索引
3. ✅ 创建回滚文件 `0004_add_tree_optimization.down.sql`
4. **注意**：无需考虑原有数据升级，当前无老数据

### ✅ 阶段二：数据模型层修改 (最高优先级) - 已完成
1. ✅ 修改 `internal/data/models.go` - 添加新的数据库字段及详细注释
2. ✅ 修改 `internal/biz/task.go` - 添加业务层字段和`Children`属性，详细说明设计思路
3. ✅ 更新数据转换器 - 完善字段转换逻辑，添加设计说明注释

### ✅ 阶段三：Repository层扩展 (高优先级) - 已完成
1. ✅ 优化现有的树查询方法 - 实现buildTreeStructure辅助方法
2. ✅ 新增根任务分页查询方法 - ListRootTasksWithPagination, ListTasksByRootIDs
3. ✅ 新增树结构维护的辅助方法 - GetCompleteTaskTree, GetTaskParentChain, UpdateTreeOptimizationFields
4. ✅ 清理重复代码 - 删除冗余的ListTaskTree功能
5. ✅ 新增日志分页查询 - ListJournalsWithPagination

### ✅ 阶段四：业务逻辑层扩展 (高优先级) - 已完成
1. ✅ 更新TaskRepo和JournalRepo接口 - 添加新方法签名
2. ✅ 新增任务树查询相关参数结构 - ListRootTasksParam, ListGlobalTaskTreeParam等
3. ✅ 实现任务树业务方法:
   * ListRootTasks - 分页查询根任务
   * ListGlobalTaskTree - 全局任务树视图（分页）
   * GetCompleteTaskTree - 获取完整任务树
   * GetTaskParentChain - 获取任务父级链路
   * CreateTaskWithTreeOptimization - 优化的创建任务方法
4. ✅ 实现日志分页业务方法 - ListJournalsWithPagination
5. ✅ 添加详细的参数验证和错误处理

### ✅ 阶段五：API层实现 (中优先级) - 已完成
1. ✅ 添加缺失的HTTP接口
   * 分页查询根任务：`GET /api/v1/tasks/roots`
   * 全局任务树视图：`GET /api/v1/tasks/tree`
   * 获取任务树：`GET /api/v1/tasks/:task_id/tree`
   * 获取父任务链：`GET /api/v1/tasks/:task_id/parents`
   * 分页查询日志：`GET /api/v1/journals/paginated`
   * 优化的任务创建：`POST /api/v1/tasks/optimized`
2. ✅ 修改现有接口添加分页支持
3. ✅ 新增任务移动接口：`PUT /api/v1/tasks/:task_id/move`（接口已创建，业务逻辑待实现）
4. ✅ 完善请求和响应数据结构
5. ✅ 添加参数验证和错误处理

### 阶段六：数据一致性保障 (低优先级)
1. 集成到现有的任务操作中
2. 提供数据修复工具

## 预期效果

### 性能提升
- **查询效率**：从递归查询优化为单次或两次查询
- **分页性能**：根任务分页 + 批量子任务查询
- **索引优化**：针对常用查询场景创建专用索引

### 功能完善
- ✅ 支持任意深度的任务树查询
- ✅ 全局任务树视图（分页）
- ✅ 父任务链查询
- ✅ 任务移动功能
- ✅ 状态过滤策略

### 用户体验
- **快速响应**：大量任务下仍能快速加载
- **直观展示**：嵌套树结构清晰展示层级关系
- **灵活操作**：支持任务移动和重新组织

## 技术风险与应对

### 数据一致性风险
- **风险**：冗余字段可能出现不一致
- **应对**：事务处理 + 定期数据校验 + 修复工具

### 复杂度风险
- **风险**：维护逻辑相对复杂
- **应对**：完善的单元测试 + 清晰的文档

### 性能权衡
- **风险**：移动大子树时需要递归更新
- **应对**：批量更新 + 可选的异步处理

## 总结

该设计方案在保持系统稳定性的前提下，通过数据库层面的优化和业务层面的增强，有效解决了任务树查询的性能问题，完善了缺失的功能，为长期大量任务的管理提供了强有力的支持。

设计理念"尽量不要隐藏自己的过往"体现了对数据完整性和个人成长追踪的重视，通过状态管理而非删除的方式，既保持了系统的简洁性，又保留了有价值的历史信息。
